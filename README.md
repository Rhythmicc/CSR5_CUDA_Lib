# CSR5_CUDA_Lib

Fork from CSR5: https://github.com/weifengliu-ssslab/Benchmark_SpMV_using_CSR5, the following content generated by AI.

## CSR5 格式核心思想
对非零元按固定规模分区：每个 partition 包含 `omega * sigma` 个元素（最后一块可能不足）。

核心组件：
- `omega (Ω)`：通常等于 warp 大小 (32)。固定后利于 warp 规约与 shuffle。
- `sigma (σ)`：每个线程（或 lane）处理的“列段”高度，可自适应选择以控制寄存器与共享内存使用。库中支持自动调参 `ANONYMOUSLIB_AUTO_TUNED_SIGMA`。
- `partition_pointer`：指向各分区覆盖的 CSR 全局位置。
- `partition_descriptor`：位打包的段信息（含 y_offset、scan sum offset、segment 边界等）。
- `partition_descriptor_offset(_pointer)`：处理含空行 (empty rows) 情况时的补充结构。
- AoSoA 转置：将 `(value, column_index)` 重新组织，使按 partition + lane 访问连续，提高内存吞吐。

## 主要特性
- CSR → CSR5 转换与逆转换 (in-place 风格重用原数组内存布局)。
- Warp 级规约 + texture 绑定读取向量 x，改善缓存命中。
- 动态 sigma 选择策略（基于 nnz/row 统计）。
- 针对含空行矩阵的健壮处理。
- CMake 打包，易于被外部工程 `find_package`。

## 项目结构
```
├── CMakeLists.txt              # 顶层构建脚本（安装导出配置）
├── cmake/csr5_cudaConfig.cmake.in
├── include/
│   ├── anonymouslib_cuda.h     # 对外核心句柄类 anonymouslibHandle
│   └── detail/...              # 内部实现（格式转换 / 内核 / 工具函数）
├── src/
│   ├── CMakeLists.txt          # 生成静态库 csr5_cuda
│   └── csr5_cuda.cu            # 入口聚合 / 内核编译单元
├── test/
│   ├── CMakeLists.txt          # 示例 / 性能 & 正确性测试
│   ├── include/mmio.h          # Matrix Market 读写
│   └── src/main.cu             # 读取 .mtx 并运行 SpMV
└── build/                      # （建议 out-of-source）编译输出
```

## 环境与依赖
- CMake >= 3.18 （需要 CUDA 语言支持；当前工程使用 3.31 也兼容）
- 支持的 GPU 架构：代码未显式限制，可根据需要在 CMake 中添加 `-arch=sm_xx`
- C++ 编译器 (g++ / clang++)

可选：MatrixMarket `.mtx` 数据集用于测试 (如 SuiteSparse Collection)。

## 构建与安装

```bash
git clone https://github.com/Rhythmicc/CSR5_CUDA_Lib.git CSR5_CUDA_Lib
cd CSR5_CUDA_Lib
mkdir -p build && cd build
cmake -DCMAKE_BUILD_TYPE=Release ..
cmake --build . -j
# 可选安装（需写权限）
cmake --install . --prefix <install_prefix>
```

安装后将生成：
```
<prefix>/lib/libcsr5_cuda.a
<prefix>/include/anonymouslib_cuda.h (及 detail/...) 
<prefix>/lib/cmake/csr5_cuda/csr5_cudaConfig.cmake
```

在其他项目中使用：
```cmake
find_package(csr5_cuda REQUIRED)
add_executable(app main.cpp)
target_link_libraries(app PRIVATE csr5_cuda::csr5_cuda)
```

## 运行示例
构建完成后，在 `build/test/` 目录会生成 `spmv_test`，示例读取 MatrixMarket：
```bash
./test/spmv_test /path/to/matrix.mtx [device_id]
```
输出包含：
- CSR→CSR5 转换各阶段时间 (malloc / tile_ptr / tile_desc / transpose)
- CSR5 SpMV 平均时间 / Bandwidth / GFlops
- 结果正确性校验 PASS/NO PASS

## 快速上手 (API 使用流程)
核心类：`anonymouslibHandle<IT, UIT, VT>`。

最小示例（假设已将 CSR 数据复制到 GPU）：
```cpp
using IT = int; using UIT = unsigned int; using VT = double; // 或 float
anonymouslibHandle<IT, UIT, VT> handle(m, n);
handle.inputCSR(nnz, d_csrRowPtr, d_csrColIdx, d_csrVal);
handle.setX(d_x);                 // 绑定 x（创建 texture）
handle.setSigma(ANONYMOUSLIB_AUTO_TUNED_SIGMA); // 或手工设定值
handle.warmup();                  // 可选：初始化内核上下文
handle.asCSR5();                  // 执行 3 步转换
handle.spmv(alpha, d_y);          // y = alpha * A * x  (beta 固定为 0)
handle.destroy();                 // 回收 texture 并回退为 CSR
```

主要方法说明：
- `inputCSR(nnz, rowPtr, colIdx, val)`：传入 GPU 端 CSR 指针。
- `setSigma(int)`：若为 `ANONYMOUSLIB_AUTO_TUNED_SIGMA`，内部按 nnz/row 范围选择 {4, nnz/row, 32, 6} 之一。
- `asCSR5()`：分配并生成 partition_pointer / descriptor / offset / AoSoA 变换。
- `spmv(alpha, y)`：当前实现相当于 `y = alpha * A * x`；无显式 beta 参数。
- `asCSR()`：逆转换回 CSR（释放 CSR5 相关 GPU 内存）。
- `destroy()`：销毁 texture + 调用 `asCSR()`。

返回值：成功 0，错误代码参考 `include/detail/common.h`。

## 关键参数与调优
| 参数 | 含义 | 影响 |
|------|------|------|
| `ANONYMOUSLIB_CSR5_OMEGA` | warp 级分块宽度 (默认 32) | 固定 32 有利于利用 warp intrinsic；改变需重新评估位宽限制。 |
| `sigma` | 每 lane 纵向高度 | 大小影响共享内存使用与并行度；自动调参已覆盖常见分布。 |
| `_bit_y_offset` / `_bit_scansum_offset` | 描述符位域长度 | 由 `(omega * sigma)` 与 `omega` 推导，不需手动改。 |
| `_num_packet` | 描述符实际占用的 packet 数 | packet = sizeof(UIT)*8 bits。 |

调优建议：
1. 运行前预估 `nnz/(m)` 均值，若极端稀疏（<4）或极端密（>256）可尝试手调 sigma。
2. 如需测试不同 sigma：在 CSR 输入后调用 `setSigma(fixed_value)` 再 `asCSR5()`。
3. 根据 GPU 架构添加编译选项：`-DCMAKE_CUDA_ARCHITECTURES=80;90` 等。

## 数据格式转换
顺序：CSR (inputCSR) → CSR5 (asCSR5) → SpMV → （可选）asCSR 回退。

转换耗时分为 4 部分：
- malloc 分配与初始化
- partition pointer 生成
- partition descriptor 生成（含空行偏移）
- AoSoA 转置 (column_index / value)

适合场景：同一稀疏矩阵重复执行多次 SpMV（迭代算法：CG、GMRES、PageRank 等）。单次 SpMV 不一定能摊平转换开销。
